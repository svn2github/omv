<?php
/**
 * This file is part of OpenMediaVault.
 *
 * @license   http://www.gnu.org/licenses/gpl.html GPL Version 3
 * @author    Volker Theile <volker.theile@openmediavault.org>
 * @copyright Copyright (c) 2009-2015 Volker Theile
 *
 * OpenMediaVault is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * OpenMediaVault is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with OpenMediaVault. If not, see <http://www.gnu.org/licenses/>.
 */
require_once("openmediavault/object.inc");
require_once("openmediavault/config.inc");
require_once("openmediavault/error.inc");
require_once("openmediavault/system.inc");
require_once("openmediavault/functions.inc");
require_once("openmediavault/rpcservice.inc");
require_once("openmediavault/notify.inc");

class OMVRpcServiceNetwork extends OMVRpcServiceAbstract {
	/**
	 * Get the RPC service name.
	 */
	public function getName() {
		return "Network";
	}

	/**
	 * Initialize the RPC service.
	 */
	public function initialize() {
		$this->registerMethod("getGeneralSettings");
		$this->registerMethod("setGeneralSettings");
		$this->registerMethod("enumerateDevices");
		$this->registerMethod("enumerateDevicesList");
		$this->registerMethod("enumerateApplicableDevices");
		$this->registerMethod("identify");
		$this->registerMethod("getIface");
		$this->registerMethod("setIface");
		$this->registerMethod("deleteIface");
		$this->registerMethod("enumerateBondSlaves");
		$this->registerMethod("getBondIface");
		$this->registerMethod("setBondIface");
		$this->registerMethod("deleteBondIface");
		$this->registerMethod("getVlanCandidates");
		$this->registerMethod("getVlanIface");
		$this->registerMethod("setVlanIface");
		$this->registerMethod("deleteVlanIface");
	}

	/**
	 * Helper function to get details of the given network interface device.
	 * @param deviceName The name of the network interface device.
	 * @return An array containing the network interface details. The following
	 *   fields are returned: devicename, gateway, gateway6, address, address6,
	 *   netmask, netmask6, ether, mtu, state, link, vlan and vlanid.
	 */
	private function getIfaceInfo($deviceName) {
		$obj = array();
		$obj['devicename'] = $deviceName;
		$obj['gateway'] = "";
		$obj['gateway6'] = "";
		$obj['address'] = "";
		$obj['address6'] = "";
		$obj['netmask'] = "";
		$obj['netmask6'] = -1;
		$obj['ether'] = "";
		$obj['mtu'] = "";
		$obj['state'] = gettext("UNKNOWN");
		$obj['link'] = FALSE;
		$obj['vlan'] = FALSE;
		$obj['vlanid'] = -1;
		$obj['speed'] = -1;
		$iface = OMVNetworkInterfaces::getImpl($deviceName);
		if (!is_null($iface) && $iface->exists()) {
			$gateway = $iface->getGateway();
			$gateway6 = $iface->getGateway6();
			$address = $iface->getIP();
			$address6 = $iface->getIP6();
			$netmask = $iface->getMask();
			$netmask6 = $iface->getMask6();
			$ether = $iface->getMAC();
			$state = $iface->getState();
			$speed = $iface->getSpeed();
			$obj['gateway'] = !$gateway ? "" : $gateway;
			$obj['gateway6'] = !$gateway6 ? "" : $gateway6;
			$obj['address'] = !$address ? "" : $address;
			$obj['address6'] = !$address6 ? "" : $address6;
			$obj['netmask'] = !$netmask ? "" : $netmask;
			$obj['netmask6'] = !$netmask6 ? -1 : $netmask6;
			$obj['ether'] = !$ether ? "" : $ether;
			$obj['mtu'] = $iface->getMTU();
			$obj['state'] = !$state ? gettext("UNKNOWN") : $state;
			$obj['link'] = $iface->getLink();
			$obj['vlan'] = $iface->isVlan();
			$obj['vlanid'] = $iface->isVlan() ? $iface->getVlanId() : -1;
			$obj['speed'] = !$speed ? -1 : $speed;
		}
		return $obj;
	}

	/**
	 * Get general network settings.
	 * @param params The method parameters.
	 * @param context The context of the caller.
	 * @return The configuration object.
	 * @throw E_CONFIG_GET_OBJECT_FAILED
	 */
	function getGeneralSettings($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Get the network settings.
		$xpath = "//system/network";
		$object = $xmlConfig->get($xpath);
		if(is_null($object)) {
			throw new OMVException(OMVErrorMsg::E_CONFIG_GET_OBJECT_FAILED,
			  $xpath);
		}
		return array(
			"hostname" => $object['hostname'],
			"domainname" => $object['domainname']
		);
	}

	/**
	 * Set general network settings.
	 * @param params The method parameters.
	 * @param context The context of the caller.
	 * @return The stored configuration object.
	 * @throw E_CONFIG_GET_OBJECT_FAILED
	 * @throw E_CONFIG_SET_OBJECT_FAILED
	 */
	function setGeneralSettings($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "hostname":{"type":"string","minLength":1},
				  "domainname":{"type":"string"}
			  }
		  }');
		// Get existing configuration object.
		$xpath = "//system/network";
		$object = $xmlConfig->get($xpath);
		if(is_null($object)) {
			throw new OMVException(OMVErrorMsg::E_CONFIG_GET_OBJECT_FAILED,
			  $xpath);
		}
		// Update the configuration object.
		$object = array_merge($object, array(
			"hostname" => $params['hostname'],
			"domainname" => $params['domainname']
		));
		if(FALSE === $xmlConfig->replace($xpath, $object)) {
			throw new OMVException(OMVErrorMsg::E_CONFIG_SET_OBJECT_FAILED);
		}
		// Notify configuration changes.
		$dispatcher = &OMVNotifyDispatcher::getInstance();
		$dispatcher->notify(OMV_NOTIFY_MODIFY,
		  "org.openmediavault.system.network.hostname", $object);
		// Return the configuration object.
		return $object;
	}

	/**
	 * Enumerate all network interface devices on the system.
	 * @param params The method parameters.
	 * @param context The context of the caller.
	 * @return An array of objects. Each object represents a network interface
	 *   device with the following properties: \em devicename, \em gateway,
	 *   \em gateway6, \em address, \em address6, \em netmask, \em netmask6,
	 *   \em ether, \em mtu, \em state, \em link, \em vlan and \em vlanid.
	 * @throw E_MISC_FAILURE
	 */
	public function enumerateDevices($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Enumerate all network interface devices on the system.
		if (FALSE === ($devs = OMVNetworkInterfaces::enumerate(
		  OMV_NETWORK_INTERFACE_TYPE_ALL))) {
			throw new OMVException(OMVErrorMsg::E_MISC_FAILURE,
			  gettext("Failed to get list of network interface devices"));
		}
		// Now get the devicename of all configured network interfaces.
		$xpath = "//system/network/interfaces//devicename";
		$configDevs = $xmlConfig->getList($xpath);
		// Finally merge both arrays.
		$devs = array_unique(array_merge($devs, $configDevs));
		// Now prepare the result objects including all information
		// about the network interface.
		$result = array();
		foreach ($devs as $devk => $devv) {
			// Get the network interface backend.
			$nib = OMVNetworkInterfaces::getBackend($devv);
			if (is_null($nib)) {
				throw new OMVException(OMVErrorMsg::E_MISC_FAILURE,
				  sprintf("No network interface backend exists for '%s'",
				  $devv));
			}
			$object = array();
			// Get the network interface configuration.
			$xpath = sprintf("//system/network/interfaces/*[devicename='%s']",
			  $devv);
			$cfgObject = $xmlConfig->get($xpath);
			if (!is_null($cfgObject))
				$object = array_merge($object, $cfgObject);
			// Get the current network interface information. Note, this will
			// override various configuration values.
			$object = array_merge($object, $this->getIfaceInfo($devv));
			// Append additional attributes.
			$object['uuid'] = $GLOBALS['OMV_UUID_UNDEFINED'];
			$object['method'] = "";
			$object['method6'] = "";
			$object['comment'] = "";
			$object['type'] = "unknown";
			$object['_used'] = FALSE;
			$object['_readonly'] = FALSE;
			// Categorize the network interface.
			switch ($nib->getType()) {
			case OMV_NETWORK_INTERFACE_TYPE_BOND:
				$object['type'] = "bond";
				break;
			case OMV_NETWORK_INTERFACE_TYPE_BRIDGE:
				$object['type'] = "bridge";
				break;
			case OMV_NETWORK_INTERFACE_TYPE_WIRELESS:
				$object['type'] = "wireless";
				break;
			case OMV_NETWORK_INTERFACE_TYPE_ETHERNET:
				$object['type'] = "ethernet";
				break;
			case OMV_NETWORK_INTERFACE_TYPE_VIRTUAL:
				$object['type'] = "virtual";
				break;
			case OMV_NETWORK_INTERFACE_TYPE_VLAN:
				$object['type'] = "vlan";
				break;
			case OMV_NETWORK_INTERFACE_TYPE_LOOPBACK:
				$object['type'] = "loopback";
				break;
			}
			// Do some more checks.
			switch ($nib->getType()) {
			case OMV_NETWORK_INTERFACE_TYPE_BOND:
				// Is the bond interface somewhere referenced?
				$xpath = sprintf("//bondifaceref[contains(.,'%s')]",
				  $object['uuid']);
				if (TRUE === $xmlConfig->exists($xpath))
					$object['_used'] = TRUE;
				break;
			case OMV_NETWORK_INTERFACE_TYPE_VLAN:
				// Is the VLAN interface somewhere referenced?
				$xpath = sprintf("//vlanifaceref[contains(.,'%s')]",
				  $object['uuid']);
				if (TRUE === $xmlConfig->exists($xpath))
					$object['_used'] = TRUE;
				break;
			default:
				// Is the ethernet interface device somewhere referenced?
				$xpath = sprintf("//ifaceref[contains(.,'%s')]",
				  $object['uuid']);
				if (TRUE === $xmlConfig->exists($xpath))
					$object['_used'] = TRUE;
				// Check if it is used by a bonding interface.
				$xpath = sprintf("//bondiface[contains(slaves,'%s')]",
				  $object['devicename']);
				if (TRUE === $xmlConfig->exists($xpath)) {
					$object['_used'] = TRUE;
					$object['_readonly'] = TRUE;
					$object['method'] = "";
					$object['method6'] = "";
				}
				break;
			}
			// Append network interface device to result list.
			$result[] = $object;
		}
		return $result;
	}

	/**
	 * Enumerate all network interface devices on the system, except loopback.
	 * @param params An array containing the following fields:
	 *   \em start The index where to start.
	 *   \em limit The number of objects to process.
	 *   \em sortfield The name of the column used to sort.
	 *   \em sortdir The sort direction, ASC or DESC.
	 * @param context The context of the caller.
	 * @return An array containing the requested objects. The field \em total
	 *   contains the total number of objects, \em data contains the object
	 *   array. An exception will be thrown in case of an error.
	 */
	function enumerateDevicesList($params, $context) {
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "start":{"type":"integer"},
				  "limit":{'.$GLOBALS['OMV_JSONSCHEMA_COUNTFIELD'].'},
				  "sortfield":{'.$GLOBALS['OMV_JSONSCHEMA_SORTFIELD'].'},
				  "sortdir":{'.$GLOBALS['OMV_JSONSCHEMA_SORTDIR'].'}
			  }
		  }');
		// Get the system network interface devices.
		$result = $this->callMethod("enumerateDevices", NULL, $context);
		// Filter the result.
		return $this->applyFilter($result, $params['start'],
		  $params['limit'], $params['sortfield'], $params['sortdir']);
	}

	/**
	 * Get all applicable network interfaces devices.
	 * @param params The method parameters.
	 * @param context The context of the caller.
	 * @return A list of applicable network interfaces devices.
	 * @throw E_CONFIG_GET_OBJECT_FAILED
	 */
	function enumerateApplicableDevices($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		$result = array();
		// Get all network interface configuration object UUID's.
		$xpath = "//system/network/interfaces//uuid";
		$uuids = $xmlConfig->getList($xpath);
		if (is_null($uuids)) {
			throw new OMVException(OMVErrorMsg::E_CONFIG_GET_OBJECT_FAILED,
			  $xpath);
		}
		// Get the system network interface devices. Only process those
		// network interfaces that have a valid UUID attribute (this means
		// there is a configuration object in the database).
		$objects = $this->callMethod("enumerateDevices", NULL, $context);
		foreach ($objects as $objectk => $objectv) {
			if (!in_array($objectv['uuid'], $uuids))
				continue;
			$result[] = $objectv;
		}
		return $result;
	}

	/**
	 * Initiate adapter-specific action intended to enable an operator to
	 * easily identify the adapter by sight. Note, the communication to the
	 * system is not possible during the given time.
	 * @param params An array containing the following fields:
	 *   \em devicename The name of the network interface device, e.g. eth1.
	 *   \em seconds Length of time in seconds to blink one or more LEDs
	 *   on the specific network interface device.
	 * @param context The context of the caller.
	 * @return The name of the background process status file.
	 * @throw E_EXEC_FAILED
	 */
	function identify($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "devicename":{"type":"string"},
				  "seconds":{"type":"integer","minimum":1,"maximum":30}
			  }
		  }');
		// Create a background process.
		$bgStatusFilename = $this->createBgProcStatus();
		$pid = $this->fork();
		if($pid > 0) { // Parent process.
			$this->initializeBgProcStatus($bgStatusFilename, $pid);
			return $bgStatusFilename;
		}
		// Child process.
		try {
			$bgOutputFilename = $this->createBgProcOutput();
			$this->updateBgProcStatus($bgStatusFilename, "outputfilename",
			  $bgOutputFilename);
			// Initiate adapter-specific action intended to enable an operator
			// to easily identify the adapter by sight.
			$cmd = sprintf("export LANG=C; ethtool --identify %s %d 2>&1",
			  $params['devicename'], $params['seconds']);
			if(0 !== $this->exec($cmd, $output, $bgOutputFilename)) {
				throw new OMVException(OMVErrorMsg::E_EXEC_FAILED,
				  $cmd, implode("\n", $output));
			}
			$this->finalizeBgProcStatus($bgStatusFilename, $output);
			exit(0);
		} catch(Exception $e) {
			$this->finalizeBgProcStatus($bgStatusFilename, "", $e);
			exit(1);
		}
	}

	/**
	 * Get a ethernet network interface configuration object.
	 * @param params An array containing the following fields:
	 *   \em uuid The UUID of the configuration object.
	 * @param context The context of the caller.
	 * @return The requested configuration object.
	 * @throw E_CONFIG_GET_OBJECT_FAILED
	 */
	function getIface($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "uuid":{'.$GLOBALS['OMV_JSONSCHEMA_UUID'].'}
			  }
		  }');
		// Get the configuration object.
		$xpath = sprintf("//system/network/interfaces/iface[uuid='%s']",
		  $params['uuid']);
		$object = $xmlConfig->get($xpath);
		if(is_null($object)) {
			throw new OMVException(OMVErrorMsg::E_CONFIG_GET_OBJECT_FAILED,
			  $xpath);
		}
		// Modify result data.
		$object['netmask6'] = intval($object['netmask6']);
		$object['wol'] = boolvalEx($object['wol']);
		if(!empty($object['mtu']))
			$object['mtu'] = intval($object['mtu']);
		$object['dnsnameservers'] = str_replace(" ", ",",
		  $object['dnsnameservers']);
		$object['dnssearch'] = str_replace(" ", ",", $object['dnssearch']);
		return $object;
	}

	/**
	 * Set (add/update) a ethernet network interface configuration object.
	 * @param params The method parameters.
	 * @param context The context of the caller.
	 * @return The stored configuration object.
	 * @throw E_CONFIG_OBJECT_UNIQUENESS
	 * @throw E_CONFIG_SET_OBJECT_FAILED
	 */
	function setIface($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "uuid":{'.$GLOBALS['OMV_JSONSCHEMA_UUID_UNDEFINED'].'},
				  "devicename":{"type":"string"},
				  "method":{"type":"string","enum":["dhcp","static",'.
					'"manual"]},
				  "address":{"type":"string"},
				  "netmask":{"type":"string"},
				  "gateway":{"type":"string"},
				  "method6":{"type":"string","enum":["auto","static",'.
					'"manual","dhcp"]},
				  "address6":{"type":"string"},
				  "netmask6":{"type":"integer","minimum":0,"maximum":128},
				  "gateway6":{"type":"string"},
				  "dnsnameservers":{"type":"string"},
				  "dnssearch":{"type":"string"},
				  "mtu":{"type":["integer","string"]},
				  "wol":{"type":"boolean"},
				  "options":{"type":"string"},
				  "comment":{"type":"string"}
			  }
		  }');
		// Prepare configuration object.
		$object = array(
			"uuid" => ($params['uuid'] == $GLOBALS['OMV_UUID_UNDEFINED']) ?
			  OMVUtil::uuid() : $params['uuid'],
			"devicename" => $params['devicename'],
			"method" => $params['method'],
			"address" => $params['address'],
			"netmask" => $params['netmask'],
			"gateway" => $params['gateway'],
			"method6" => $params['method6'],
			"address6" => $params['address6'],
			"netmask6" => $params['netmask6'],
			"gateway6" => $params['gateway6'],
			"dnsnameservers" => preg_replace("/[,;]/", " ",
			  $params['dnsnameservers']),
			"dnssearch" => preg_replace("/[,;]/", " ", $params['dnssearch']),
			"mtu" => $params['mtu'],
			"wol" => array_boolval($params, 'wol'),
			"options" => $params['options'],
			"comment" => $params['comment']
		);
		// Set configuration data
		$success = FALSE;
		if($params['uuid'] == $GLOBALS['OMV_UUID_UNDEFINED']) {
			// Check uniqueness.
			$xpath = sprintf("//system/network/interfaces/iface[".
			  "devicename='%s']", $object['devicename']);
			if(TRUE === $xmlConfig->exists($xpath)) {
				throw new OMVException(OMVErrorMsg::E_CONFIG_OBJECT_UNIQUENESS,
				  sprintf(gettext("Network interface '%s' already exists"),
				  $object['devicename']));
			}
			// Append object to configuration.
			$success = $xmlConfig->set("//system/network/interfaces",
			  array("iface" => $object));
		} else {
			// Update existing configuration object.
			$xpath = sprintf("//system/network/interfaces/iface[uuid='%s']",
			  $params['uuid']);
			$success = $xmlConfig->replace($xpath, $object);
		}
		if(FALSE === $success) {
			throw new OMVException(OMVErrorMsg::E_CONFIG_SET_OBJECT_FAILED);
		}
		// Notify configuration changes.
		$dispatcher = &OMVNotifyDispatcher::getInstance();
		$dispatcher->notify(($params['uuid'] == $GLOBALS['OMV_UUID_UNDEFINED']) ?
		  OMV_NOTIFY_CREATE : OMV_NOTIFY_MODIFY,
		  "org.openmediavault.system.network.interfaces.iface", $object);
		// Return the configuration object.
		return $object;
	}

	/**
	 * Delete a ethernet network interface configuration object.
	 * @param params An array containing the following fields:
	 *   \em uuid The UUID of the configuration object.
	 * @param context The context of the caller.
	 * @return The deleted configuration object.
	 */
	function deleteIface($params, $context) {
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "uuid":{'.$GLOBALS['OMV_JSONSCHEMA_UUID'].'}
			  }
		  }');
		// Delete the configuration object.
		$xpath = sprintf("//system/network/interfaces/iface[uuid='%s']",
		  $params['uuid']);
		return $this->deleteConfigObjectByPath($xpath,
		  "org.openmediavault.system.network.interfaces.iface");
	}

	/**
	 * Enumerate all interfaces from a bonded interface object.
	 * @param params An array containing the following fields:
	 *   \em uuid The UUID of the bonded interface configuration object.
	 *   \em unused If TRUE then the ethernet network interfaces that are
	 *   not configured nor used will be appended to the result list.
	 *   Defaults to TRUE.
	 * @param context The context of the caller.
	 * @return If \em uuid is set to OMV_UUID_UNDEFINED a list of available
	 *   ethernet network interfaces (iface class objects) is returned,
	 *   otherwise the bonded interface slaves plus the unreferenced ethernet
	 *   network interfaces are returned.
	 * @throw E_MISC_DEVICE_NOT_SUPPORTED
	 * @throw E_CONFIG_GET_OBJECT_FAILED
	 */
	public function enumerateBondSlaves($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "uuid":{'.$GLOBALS['OMV_JSONSCHEMA_UUID_UNDEFINED'].'},
				  "unused":{"type":"boolean"}
			  }
		  }');
		// Get list of network interfaces.
		$result = array();
		if (array_key_exists("unused", $params) && $params['unused'] === TRUE) {
			// Get all unused network interface devices, except loopback and
			// VLAN network interfaces.
			if (FALSE === ($devs = OMVNetworkInterfaces::enumerateUnused(
			  OMV_NETWORK_INTERFACE_TYPE_ALL & ~(OMV_NETWORK_INTERFACE_TYPE_VLAN |
			  OMV_NETWORK_INTERFACE_TYPE_LOOPBACK)))) {
				throw new OMVException(OMVErrorMsg::E_MISC_FAILURE,
				  gettext("Failed to get list of unused network interface devices"));
			}
			// Get a list of configured ethernet network interfaces that are
			// not used by any other config object.
			foreach ($devs as $devk => $devv) {
				// Is network interface device referenced somewhere:
				// - Check if the interface is already used by a bond
				//   interface.
				$xpath = sprintf("//system/network/interfaces/bondiface".
				  "[contains(slaves,'%s')]", $devv);
				if (TRUE === $xmlConfig->exists($xpath))
					continue;
				// - Check if the interface is already used by a VLAN
				//   interface.
				$xpath = sprintf("//system/network/interfaces/vlaniface".
				  "[contains(vlanrawdevice,'%s')]", $devv);
				if (TRUE === $xmlConfig->exists($xpath))
					continue;
				// - Does a configuration object exists for the given
				//   network interface device?
				$xpath = sprintf("//system/network/interfaces/iface[".
				  "devicename='%s']", $devv);
				$object = $xmlConfig->get($xpath);
				if (!is_null($object))
					continue;
				// Get the network interface information.
				$result[] = $this->getIfaceInfo($devv);
			}
		}
		if ($params['uuid'] !== $GLOBALS['OMV_UUID_UNDEFINED']) {
			// Get network interfaces already assigned to the bonding
			// interface device.
			$xpath = sprintf("//system/network/interfaces/bondiface[uuid='%s']",
			  $params['uuid']);
			$object = $xmlConfig->get($xpath);
			if (is_null($object)) {
				throw new OMVException(OMVErrorMsg::E_CONFIG_GET_OBJECT_FAILED,
				  $xpath);
			}
			// Get interface details of the bonding slaves.
			foreach (explode(",", $object['slaves']) as $slavek => $slavev) {
				$result[] = $this->getIfaceInfo($slavev);
			}
			// Remove the bond interface itself from the result list.
			foreach ($result as $resultk => $resultv) {
				if ($resultv['devicename'] !== $object['devicename'])
					continue;
				// Remove the item and re-index array.
				unset($result[$resultk]);
				$result = array_values($result);
				break;
			}
		}
		return $result;
	}

	/**
	 * Get a bonded interface configuration object.
	 * @param params An array containing the following fields:
	 *   \em uuid The UUID of the configuration object.
	 * @param context The context of the caller.
	 * @return The requested configuration object.
	 * @throw E_CONFIG_GET_OBJECT_FAILED
	 */
	function getBondIface($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "uuid":{'.$GLOBALS['OMV_JSONSCHEMA_UUID'].'}
			  }
		  }');
		// Get the configuration object.
		$xpath = sprintf("//system/network/interfaces/bondiface[uuid='%s']",
		  $params['uuid']);
		$object = $xmlConfig->get($xpath);
		if(is_null($object)) {
			throw new OMVException(OMVErrorMsg::E_CONFIG_GET_OBJECT_FAILED,
			  $xpath);
		}
		// Modify result data.
		$object['netmask6'] = intval($object['netmask6']);
		$object['wol'] = boolvalEx($object['wol']);
		if(!empty($object['mtu']))
			$object['mtu'] = intval($object['mtu']);
		$object['bondmode'] = intval($object['bondmode']);
		$object['bondmiimon'] = intval($object['bondmiimon']);
		$object['bonddowndelay'] = intval($object['bonddowndelay']);
		$object['bondupdelay'] = intval($object['bondupdelay']);
		$object['dnsnameservers'] = str_replace(" ", ",",
		  $object['dnsnameservers']);
		$object['dnssearch'] = str_replace(" ", ",", $object['dnssearch']);
		return $object;
	}

	/**
	 * Set (add/update) a bonded interface config object.
	 * @param params The method parameters.
	 * @param context The context of the caller.
	 * @return The stored configuration object.
	 * @throw E_CONFIG_SET_OBJECT_FAILED
	 */
	function setBondIface($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "uuid":{'.$GLOBALS['OMV_JSONSCHEMA_UUID_UNDEFINED'].'},
				  "devicename":{"type":"string"},
				  "method":{"type":"string","enum":["dhcp","static",'.
					'"manual"]},
				  "address":{"type":"string"},
				  "netmask":{"type":"string"},
				  "gateway":{"type":"string"},
				  "method6":{"type":"string","enum":["auto","static",'.
					'"manual","dhcp"]},
				  "address6":{"type":"string"},
				  "netmask6":{"type":"integer","minimum":0,"maximum":128},
				  "gateway6":{"type":"string"},
				  "dnsnameservers":{"type":"string"},
				  "dnssearch":{"type":"string"},
				  "mtu":{"type":["integer","string"]},
				  "wol":{"type":"boolean"},
				  "options":{"type":"string"},
				  "comment":{"type":"string"},
				  "slaves":{"type":"string","format":"regex","pattern":'.
					'"\/^((eth|wlan)\\\d+,)*(eth|wlan)\\\d+$\/i"},
				  "bondprimary":{"type":"string"},
				  "bondmode":{"type":"integer","enum":[0,1,2,3,4,5,6]},
				  "bondmiimon":{"type":"integer","minimum":0},
				  "bonddowndelay":{"type":"integer","minimum":0},
				  "bondupdelay":{"type":"integer","minimum":0}
			  }
		  }');
		// Do some additional tests.
		// - The primary option is only valid for active-backup(1),
		//   balance-tlb (5) and balance-alb (6) mode.
		//   See https://www.kernel.org/doc/Documentation/networking/bonding.txt
		if (empty($params['bondprimary']) && in_array($params['bondmode'],
		  array(1, 5, 6))) {
			throw new OMVException(OMVErrorMsg::E_RPC_SERVICE_METHOD_INVALID_PARAMS,
			  "bondprimary; bondmode");
		}
		// Prepare the configuration object.
		$object = array(
			"uuid" => ($params['uuid'] == $GLOBALS['OMV_UUID_UNDEFINED']) ?
			  OMVUtil::uuid() : $params['uuid'],
			"method" => $params['method'],
			"address" => $params['address'],
			"netmask" => $params['netmask'],
			"gateway" => $params['gateway'],
			"method6" => $params['method6'],
			"address6" => $params['address6'],
			"netmask6" => $params['netmask6'],
			"gateway6" => $params['gateway6'],
			"dnsnameservers" => preg_replace("/[,;]/", " ",
			  $params['dnsnameservers']),
			"dnssearch" => preg_replace("/[,;]/", " ", $params['dnssearch']),
			"mtu" => $params['mtu'],
			"wol" => array_boolval($params, 'wol'),
			"options" => $params['options'],
			"comment" => $params['comment'],
			"bondprimary" => $params['bondprimary'],
			"bondmode" => $params['bondmode'],
			"bondmiimon" => $params['bondmiimon'],
			"bonddowndelay" => $params['bonddowndelay'],
			"bondupdelay" => $params['bondupdelay'],
			"slaves" => $params['slaves']
		);
		// Set the configuration object.
		$success = FALSE;
		if($params['uuid'] == $GLOBALS['OMV_UUID_UNDEFINED']) {
			// Check if the slaves are already used by a bonding interface.
			foreach(explode(",", $object['slaves']) as $slavek => $slavev) {
				$xpath = sprintf("//system/network/interfaces/bondiface[".
				  "contains(slaves,'%s')]", $slavev);
				if(TRUE === $xmlConfig->exists($xpath)) {
					throw new OMVException(OMVErrorMsg::E_CONFIG_OBJECT_UNIQUENESS,
					  sprintf(gettext("The interface '%s' is already used by a bonding interface"),
					  $slavev));
				}
			}
			// Get the next free device name.
			$object['devicename'] = OMVSystem::getNextDevice("iface", "bond");
			// Append object to configuration.
			$success = $xmlConfig->set("//system/network/interfaces",
			  array("bondiface" => $object));
		} else {
			$object['devicename'] = $params['devicename'];
			// Update existing configuration object.
			$xpath = sprintf("//system/network/interfaces/bondiface[uuid='%s']",
			  $params['uuid']);
			$success = $xmlConfig->replace($xpath, $object);
		}
		if(FALSE === $success) {
			throw new OMVException(OMVErrorMsg::E_CONFIG_SET_OBJECT_FAILED);
		}
		// Notify configuration changes.
		$dispatcher = &OMVNotifyDispatcher::getInstance();
		$dispatcher->notify(($params['uuid'] == $GLOBALS['OMV_UUID_UNDEFINED']) ?
		  OMV_NOTIFY_CREATE : OMV_NOTIFY_MODIFY,
		  "org.openmediavault.system.network.interfaces.bondiface", $object);
		// Return the configuration object.
		return $object;
	}

	/**
	 * Delete a bonded interface configuration object.
	 * @param params An array containing the following fields:
	 *   \em uuid The UUID of the configuration object.
	 * @param context The context of the caller.
	 * @return The deleted configuration object.
	 */
	function deleteBondIface($params, $context) {
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "uuid":{'.$GLOBALS['OMV_JSONSCHEMA_UUID'].'}
			  }
		  }');
		// Delete the configuration object.
		$xpath = sprintf("//system/network/interfaces/bondiface[uuid='%s']",
		  $params['uuid']);
		return $this->deleteConfigObjectByPath($xpath,
		  "org.openmediavault.system.network.interfaces.bondiface");
	}

	/**
	 * Get list of devices that can be used to create a VLAN network
	 * interface.
	 * @param params The method parameters.
	 * @param context The context of the caller.
	 * @return An array containing network interface objects.
	 * @throw E_EXEC_MISC
	 */
	public function getVlanCandidates($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Get all unused network interface devices, except loopback and
		// VLAN network interfaces.
		if (FALSE === ($devs = OMVNetworkInterfaces::enumerateUnused(
		  OMV_NETWORK_INTERFACE_TYPE_ALL & ~(OMV_NETWORK_INTERFACE_TYPE_VLAN |
		  OMV_NETWORK_INTERFACE_TYPE_LOOPBACK)))) {
			throw new OMVException(OMVErrorMsg::E_MISC_FAILURE,
			gettext("Failed to get list of unused network interface devices"));
		}
		// Get the network interface information.
		$result = array();
		foreach ($devs as $devk => $devv) {
			$result[] = $this->getIfaceInfo($devv);
		}
		return $result;
	}

	/**
	 * Get a VLAN network interface configuration object.
	 * @param params An array containing the following fields:
	 *   \em uuid The UUID of the configuration object.
	 * @param context The context of the caller.
	 * @return The requested configuration object.
	 * @throw E_CONFIG_GET_OBJECT_FAILED
	 */
	function getVlanIface($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "uuid":{'.$GLOBALS['OMV_JSONSCHEMA_UUID'].'}
			  }
		  }');
		// Get the configuration object.
		$xpath = sprintf("//system/network/interfaces/vlaniface[uuid='%s']",
		  $params['uuid']);
		$object = $xmlConfig->get($xpath);
		if (is_null($object)) {
			throw new OMVException(OMVErrorMsg::E_CONFIG_GET_OBJECT_FAILED,
			  $xpath);
		}
		// Modify result data.
		$object['netmask6'] = intval($object['netmask6']);
		$object['vlanid'] = intval($object['vlanid']);
		$object['wol'] = boolvalEx($object['wol']);
		if (!empty($object['mtu']))
			$object['mtu'] = intval($object['mtu']);
		$object['dnsnameservers'] = str_replace(" ", ",",
		  $object['dnsnameservers']);
		$object['dnssearch'] = str_replace(" ", ",", $object['dnssearch']);
		return $object;
	}

	/**
	 * Set (add/update) a VLAN network interface configuration object.
	 * @param params The method parameters.
	 * @param context The context of the caller.
	 * @return The stored configuration object.
	 * @throw E_CONFIG_OBJECT_UNIQUENESS
	 * @throw E_CONFIG_SET_OBJECT_FAILED
	 */
	function setVlanIface($params, $context) {
		global $xmlConfig;
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "uuid":{'.$GLOBALS['OMV_JSONSCHEMA_UUID_UNDEFINED'].'},
				  "devicename":{"type":"string"},
				  "method":{"type":"string","enum":["dhcp","static",'.
					'"manual"]},
				  "address":{"type":"string"},
				  "netmask":{"type":"string"},
				  "gateway":{"type":"string"},
				  "method6":{"type":"string","enum":["auto","static",'.
					'"manual","dhcp"]},
				  "address6":{"type":"string"},
				  "netmask6":{"type":"integer","minimum":0,"maximum":128},
				  "gateway6":{"type":"string"},
				  "dnsnameservers":{"type":"string"},
				  "dnssearch":{"type":"string"},
				  "mtu":{"type":["integer","string"]},
				  "wol":{"type":"boolean"},
				  "options":{"type":"string"},
				  "comment":{"type":"string"},
				  "vlanid":{"type":"integer","minimum":1,"maximum":4095},
				  "vlanrawdevice":{"type":"string"}
			  }
		  }');
		// Prepare configuration object.
		$object = array(
			"uuid" => ($params['uuid'] == $GLOBALS['OMV_UUID_UNDEFINED']) ?
			  OMVUtil::uuid() : $params['uuid'],
			"devicename" => sprintf("%s.%d", $params['vlanrawdevice'],
			  $params['vlanid']),
			"method" => $params['method'],
			"address" => $params['address'],
			"netmask" => $params['netmask'],
			"gateway" => $params['gateway'],
			"method6" => $params['method6'],
			"address6" => $params['address6'],
			"netmask6" => $params['netmask6'],
			"gateway6" => $params['gateway6'],
			"dnsnameservers" => preg_replace("/[,;]/", " ",
			  $params['dnsnameservers']),
			"dnssearch" => preg_replace("/[,;]/", " ", $params['dnssearch']),
			"mtu" => $params['mtu'],
			"wol" => array_boolval($params, 'wol'),
			"options" => $params['options'],
			"comment" => $params['comment'],
			"vlanid" => $params['vlanid'],
			"vlanrawdevice" => $params['vlanrawdevice']
		);
		// Set configuration data
		$success = FALSE;
		if ($params['uuid'] == $GLOBALS['OMV_UUID_UNDEFINED']) {
			// Check uniqueness.
			$xpath = sprintf("//system/network/interfaces/vlaniface[".
			  "devicename='%s']", $object['devicename']);
			if (TRUE === $xmlConfig->exists($xpath)) {
				throw new OMVException(OMVErrorMsg::E_CONFIG_OBJECT_UNIQUENESS,
				  sprintf(gettext("Network interface '%s' already exists"),
				  $object['devicename']));
			}
			// Append object to configuration.
			$success = $xmlConfig->set("//system/network/interfaces",
			  array("vlaniface" => $object));
		} else {
			// Update existing configuration object.
			$xpath = sprintf("//system/network/interfaces/vlaniface[uuid='%s']",
			  $params['uuid']);
			$success = $xmlConfig->replace($xpath, $object);
		}
		if (FALSE === $success)
			throw new OMVException(OMVErrorMsg::E_CONFIG_SET_OBJECT_FAILED);
		// Notify configuration changes.
		$dispatcher = &OMVNotifyDispatcher::getInstance();
		$dispatcher->notify(($params['uuid'] == $GLOBALS['OMV_UUID_UNDEFINED']) ?
		  OMV_NOTIFY_CREATE : OMV_NOTIFY_MODIFY,
		  "org.openmediavault.system.network.interfaces.vlaniface", $object);
		// Return the configuration object.
		return $object;
	}

	/**
	 * Delete a VLAN network interface configuration object.
	 * @param params An array containing the following fields:
	 *   \em uuid The UUID of the configuration object.
	 * @param context The context of the caller.
	 * @return The deleted configuration object.
	 */
	function deleteVlanIface($params, $context) {
		// Validate the RPC caller context.
		$this->validateMethodContext($context, array(
			  "role" => OMV_ROLE_ADMINISTRATOR
		  ));
		// Validate the parameters of the RPC service method.
		$this->validateMethodParams($params, '{
			  "type":"object",
			  "properties":{
				  "uuid":{'.$GLOBALS['OMV_JSONSCHEMA_UUID'].'}
			  }
		  }');
		// Delete the configuration object.
		$xpath = sprintf("//system/network/interfaces/vlaniface[uuid='%s']",
		  $params['uuid']);
		return $this->deleteConfigObjectByPath($xpath,
		  "org.openmediavault.system.network.interfaces.vlaniface");
	}
}

// Register the RPC service.
$rpcServiceMgr = &OMVRpcServiceMgr::getInstance();
$rpcServiceMgr->registerService(new OMVRpcServiceNetwork());
?>
